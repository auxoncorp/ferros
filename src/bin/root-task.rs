// NOTE: this file is generated by fel4
// NOTE: Don't edit it here; your changes will be lost at the next build!
#![no_std]
#![cfg_attr(feature = "alloc", feature(alloc))]
#![feature(lang_items, core_intrinsics)]
#![feature(global_asm)]
#![feature(panic_info_message)]

#[cfg(feature = "alloc")]
extern crate alloc;
extern crate iron_pegasus;
#[cfg(all(feature = "test", feature = "alloc"))]
extern crate proptest;
extern crate sel4_sys;
#[cfg(feature = "alloc")]
extern crate wee_alloc;

use core::alloc::Layout;
use core::intrinsics;
use core::mem;
use core::panic::PanicInfo;
use sel4_sys::*;

#[cfg(feature = "alloc")]
#[global_allocator]
static ALLOCATOR: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

macro_rules! debug_print {
    ($($arg:tt)*) => ({
        use core::fmt::Write;
        DebugOutHandle.write_fmt(format_args!($($arg)*)).unwrap();
    });
}

macro_rules! debug_println {
    ($fmt:expr) => (debug_print!(concat!($fmt, "\n")));
    ($fmt:expr, $($arg:tt)*) => (debug_print!(concat!($fmt, "\n"), $($arg)*));
}

// include the seL4 kernel configurations
#[allow(dead_code)]
#[allow(non_upper_case_globals)]
pub mod sel4_config {
    pub const KernelDebugBuild: bool = true;
    pub const KernelTimerTickMS: &'static str = "2";
    pub const KernelArmExportPMUUser: bool = false;
    pub const BuildWithCommonSimulationSettings: bool = true;
    pub const HardwareDebugAPI: bool = false;
    pub const KernelDebugDisableL2Cache: bool = false;
    pub const LibSel4FunctionAttributes: &'static str = "public";
    pub const KernelMaxNumNodes: &'static str = "1";
    pub const KernelFPUMaxRestoresSinceSwitch: &'static str = "64";
    pub const KernelStackBits: &'static str = "12";
    pub const KernelBenchmarks: &'static str = "none";
    pub const KernelColourPrinting: bool = true;
    pub const ElfloaderMode: &'static str = "secure supervisor";
    pub const KernelNumPriorities: &'static str = "256";
    pub const LinkPageSize: &'static str = "4096";
    pub const KernelVerificationBuild: bool = false;
    pub const LibSel4DebugFunctionInstrumentation: &'static str = "none";
    pub const UserLinkerGCSections: bool = false;
    pub const KernelIPCBufferLocation: &'static str = "threadID_register";
    pub const KernelRootCNodeSizeBits: &'static str = "19";
    pub const KernelFWholeProgram: bool = false;
    pub const ElfloaderErrata764369: bool = true;
    pub const KernelMaxNumBootinfoUntypedCaps: &'static str = "230";
    pub const KernelARMPlatform: &'static str = "sabre";
    pub const KernelPrinting: bool = true;
    pub const KernelDebugDisableBranchPrediction: bool = false;
    pub const KernelUserStackTraceLength: &'static str = "16";
    pub const KernelAArch32FPUEnableContextSwitch: bool = true;
    pub const KernelArmEnableA9Prefetcher: bool = false;
    pub const KernelArch: &'static str = "arm";
    pub const ElfloaderImage: &'static str = "elf";
    pub const KernelRetypeFanOutLimit: &'static str = "256";
    pub const LibSel4DebugAllocBufferEntries: &'static str = "0";
    pub const KernelTimeSlice: &'static str = "5";
    pub const KernelFastpath: bool = true;
    pub const KernelArmSel4Arch: &'static str = "aarch32";
    pub const KernelResetChunkBits: &'static str = "8";
    pub const KernelNumDomains: &'static str = "1";
    pub const KernelMaxNumWorkUnitsPerPreemption: &'static str = "100";
    pub const KernelOptimisation: &'static str = "-O2";
}

pub static mut BOOTINFO: *mut seL4_BootInfo = (0 as *mut seL4_BootInfo);
static mut RUN_ONCE: bool = false;

#[no_mangle]
pub unsafe extern "C" fn __sel4_start_init_boot_info(bootinfo: *mut seL4_BootInfo) {
    if !RUN_ONCE {
        BOOTINFO = bootinfo;
        RUN_ONCE = true;
        seL4_SetUserData((*bootinfo).ipcBuffer as usize as seL4_Word);
    }
}

#[lang = "termination"]
trait Termination {
    fn report(self) -> i32;
}

impl Termination for () {
    fn report(self) -> i32 {
        0
    }
}

#[lang = "start"]
fn lang_start<T: Termination + 'static>(
    main: fn() -> T,
    _argc: isize,
    _argv: *const *const u8,
) -> isize {
    main();
    panic!("Root task should never return from main!");
}

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    #[cfg(feature = "KernelPrinting")]
    {
        use core::fmt::Write;

        if let Some(loc) = info.location() {
            let _ = write!(
                sel4_sys::DebugOutHandle,
                "panic at {}:{}: ",
                loc.file(),
                loc.line()
            );
        } else {
            let _ = write!(sel4_sys::DebugOutHandle, "panic: ");
        }

        if let Some(fmt) = info.message() {
            let _ = sel4_sys::DebugOutHandle.write_fmt(*fmt);
        }
        let _ = sel4_sys::DebugOutHandle.write_char('\n');

        let _ = write!(
            sel4_sys::DebugOutHandle,
            "----- aborting from panic -----\n"
        );
    }
    unsafe { intrinsics::abort() }
}

#[lang = "eh_personality"]
#[no_mangle]
pub fn eh_personality() {
    #[cfg(feature = "KernelPrinting")]
    {
        use core::fmt::Write;
        let _ = write!(
            sel4_sys::DebugOutHandle,
            "----- aborting from eh_personality -----\n"
        );
    }
    unsafe {
        core::intrinsics::abort();
    }
}

#[lang = "oom"]
#[no_mangle]
pub extern "C" fn oom(_layout: Layout) -> ! {
    #[cfg(feature = "KernelPrinting")]
    {
        use core::fmt::Write;
        let _ = write!(
            sel4_sys::DebugOutHandle,
            "----- aborting from out-of-memory -----\n"
        );
    }
    unsafe { core::intrinsics::abort() }
}

const CHILD_STACK_SIZE: usize = 4096;
static mut CHILD_STACK: *const [u64; CHILD_STACK_SIZE] = &[0; CHILD_STACK_SIZE];

use core::mem::size_of;
use iron_pegasus::fancy::{
    self, wrap_untyped, ASIDControl, ASIDPool, CNode, Capability, ChildCapability, Endpoint, Page,
    PageDirectory, PageTable, ThreadControlBlock, Untyped,
};
use iron_pegasus::micro_alloc::{self, GetUntyped};
use typenum::{Unsigned, U12, U19, U20, U256, U8};

fn main() {
    let bootinfo = unsafe { &*BOOTINFO };
    let root_cnode = fancy::root_cnode(&bootinfo);
    let mut allocator =
        micro_alloc::Allocator::bootstrap(&bootinfo).expect("Couldn't set up bootstrap allocator");

    debug_println!("Made root cnode: {:?}\n\n", root_cnode);

    // find an untyped of size 20 bits (1 meg)
    let one_meg = allocator
        .get_untyped::<U20>()
        .expect("Couldn't find initial untyped");

    // q: 18 bits
    let (q1, q2, q3, q4, root_cnode) = one_meg.quarter(root_cnode).expect("first quartering");

    // r: 16 bits
    let (r1, r2, r3, r4, root_cnode) = q1.quarter(root_cnode).expect("second quartering");

    // s: 14 bits
    let (s1, s2, s3, s4, root_cnode) = r1.quarter(root_cnode).expect("fourth quartering");

    // t: 12 bits
    let (t1, t2, t3, t4, root_cnode) = s1.quarter(root_cnode).expect("fifth quartering");
    let (t5, t6, t7, t8, root_cnode) = s2.quarter(root_cnode).expect("sixth quartering");

    let (child_cnode, root_cnode) = r2
        .retype_local_cnode::<_, U12>(root_cnode)
        .expect("Couldn't retype to child proc cnode");
    debug_println!(
        "retyped child proc cnode {:?} {:?}\n\n",
        child_cnode,
        root_cnode
    );

    // TODO: Need to duplicate this endpoint into the child cnode
    let (fault_endpoint, root_cnode): (Capability<Endpoint>, _) = t2
        .retype_local(root_cnode)
        .expect("Couldn't retype fault endpoint");
    debug_println!(
        "retyped child proc endpoint {:?} {:?}\n\n",
        fault_endpoint,
        root_cnode
    );

    let (mut child_tcb, root_cnode): (Capability<ThreadControlBlock>, _) = t3
        .retype_local(root_cnode)
        .expect("couldn't retyped to tcb");
    debug_println!(
        "retyped as thread control block {:?} {:?}\n\n",
        child_tcb,
        root_cnode
    );

    let asid_control = Capability::<ASIDControl>::wrap_cptr(seL4_CapASIDControl as usize);

    let (mut asid_pool, root_cnode): (Capability<ASIDPool>, _) = t4
        .retype_asid_pool(asid_control, root_cnode)
        .expect("retype asid pool");

    let (mut child_page_directory, root_cnode): (Capability<PageDirectory>, _) =
        s3.retype_local(root_cnode).expect("retype page directory");
    // Capability::<PageDirectory>::wrap_cptr(seL4_CapInitThreadVSpace as usize);

    asid_pool
        .assign(&mut child_page_directory)
        .expect("asid pool assign");

    let (child_page_table, root_cnode): (Capability<PageTable>, _) =
        t5.retype_local(root_cnode).expect("retype page table");

    let stack_base = 0x10000000;

    child_page_directory
        .map_page_table(&child_page_table, stack_base)
        .expect("map page table");

    debug_println!("mapped page table {:?}\n\n", child_page_table);

    let (child_stack_page, root_cnode): (Capability<Page>, _) = t6
        .retype_local(root_cnode)
        .expect("retype child stack page");

    child_page_directory
        .map_page(&child_stack_page, stack_base)
        .expect("map child stack page");

    debug_println!(
        "mapped child stack page {:?} at 0x{:08x}\n\n",
        child_stack_page,
        stack_base
    );

    // map in the user image

    // arm-none-eabi-readelf -a target/armv7-sel4-fel4/debug/root-task told me this:
    //
    // [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
    // [ 8] .text             PROGBITS        00010300 000300 01c21c 00  AX  0   0  8
    //
    // looks like the .text section is where the code is. We need some way to
    // get access to its address here in userland, but for now I'll hardcode it.

    // the paging structures are sized like this:
    // page directory: address bits 20 - 31
    // page table:     address bits 12 - 19

    //     28   24   20   16   12    8    4    0
    // 0b1111 1111 1111 1111 1111 1111 1111 1111
    //   --directory--- --table-- ----page-----

    // TODO: This is the page-aligned address where the program data starts. I
    // found this out from readelf. We need some basis for these numbers, and a
    // way to get them automatically.
    let program_vaddr_start = 0x00010000;
    let program_vaddr_end = program_vaddr_start + 0x00060000;

    let (frame_page_table, root_cnode): (Capability<PageTable>, _) =
        t7.retype_local(root_cnode).expect("alloc frame page table");

    child_page_directory
        .map_page_table(&frame_page_table, program_vaddr_start)
        .expect("map frame page table");

    debug_println!("mapped page table at 0x{:08x}\n\n", program_vaddr_start);

    let (dest_reservation_iter, root_cnode) = root_cnode.reservation_iter::<U256>();
    let frame_iter = (bootinfo.userImageFrames.start..bootinfo.userImageFrames.end);
    let vaddr_iter = (program_vaddr_start..program_vaddr_end).step_by(0x1000);

    // This is, in theory, described on page 44 of the manual.
    for ((page_cptr, dest_cnode), vaddr) in frame_iter.zip(dest_reservation_iter).zip(vaddr_iter) {
        let page_cap = Capability::<Page>::wrap_cptr(page_cptr as usize);
        // let copied_page_cap = Capability::<Page>::wrap_cptr(copy_dest_slot as usize);
        let (copied_page_cap, _) = page_cap
            .copy_local(dest_cnode, unsafe { seL4_CapRights_new(0, 1, 0) })
            .expect("copy user image page cap");

        child_page_directory
            .map_page(&copied_page_cap, vaddr)
            .expect("map user image page");
    }

    debug_println!("mapped user image pages at vaddr {:08x}\n\n", program_vaddr_end);

    child_tcb
        .configure(
            // fault_endpoint,
            child_cnode,
            child_page_directory,
        )
        .expect("Couldn't configure child tcb");

    debug_println!("configured child tcb!\n\n",);

    // TODO: this isn't quite right, but it's within the mapped area at least.
    let stack_top = stack_base + 0xfff;
    let mut regs: seL4_UserContext = unsafe { mem::zeroed() };
    #[cfg(feature = "test")]
    {
        regs.pc = iron_pegasus::fel4_test::run as seL4_Word;
    }
    #[cfg(not(feature = "test"))]
    {
        regs.pc = iron_pegasus::run as seL4_Word;
    }
    regs.sp = stack_top as seL4_Word;

    debug_println!(
        "Configured regs: PC=0x{:08x}, SP=0x{:08x}\n\n",
        regs.pc,
        regs.sp
    );

    let _: u32 = unsafe { seL4_TCB_WriteRegisters(child_tcb.cptr as u32, 0, 0, 2, &mut regs) };
    let _: u32 =
        unsafe { seL4_TCB_SetPriority(child_tcb.cptr as u32, seL4_CapInitThreadTCB.into(), 255) };
    let _: u32 = unsafe { seL4_TCB_Resume(child_tcb.cptr as u32) };
    loop {
        unsafe {
            seL4_Yield();
        }
    }
}

global_asm!(
    r###"/* Copyright (c) 2015 The Robigalia Project Developers
 * Licensed under the Apache License, Version 2.0
 * <LICENSE-APACHE or
 * http://www.apache.org/licenses/LICENSE-2.0> or the MIT
 * license <LICENSE-MIT or http://opensource.org/licenses/MIT>,
 * at your option. All files in the project carrying such
 * notice may not be copied, modified, or distributed except
 * according to those terms.
 */
.global _sel4_start
.global _start
.global _stack_bottom
.text

_start:
_sel4_start:
    ldr sp, =_stack_top
    /* r0, the first arg in the calling convention, is set to the bootinfo
     * pointer on startup. */
    bl __sel4_start_init_boot_info
    /* zero argc, argv */
    mov r0, #0
    mov r1, #0
    /* Now go to the "main" stub that rustc generates */
    bl main

.pool
    .data
    .align 4
    .bss
    .align  8
_stack_bottom:
    .space  65536
_stack_top:
"###
);
